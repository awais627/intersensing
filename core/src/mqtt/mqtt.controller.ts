import { Controller, Logger } from "@nestjs/common";
import {
  Ctx,
  MessagePattern,
  MqttContext,
  Payload,
} from "@nestjs/microservices";
import { ApiOperation, ApiTags } from "@nestjs/swagger";
import { MqttService } from "./mqtt.service";
import {
  MqttTelemetryDto,
  MqttAlertDto,
  MqttCommandDto,
  MqttResponseDto,
} from "./dto/mqtt-message.dto";
import { ITelemetry } from "../common/interfaces/telemetry";

@ApiTags("MQTT")
@Controller()
export class MqttController {
  private readonly logger = new Logger(MqttController.name);

  constructor(private readonly mqttService: MqttService) {}

  @MessagePattern("demo/topic")
  @ApiOperation({ summary: "Handle demo MQTT topic" })
  handleDemo(
    @Payload() data: any,
    @Ctx() context: MqttContext,
  ): MqttResponseDto {
    this.logger.log(`üì° Received on ${context.getTopic()}:`, data);
    return {
      success: true,
      message: "Received your MQTT message!",
      timestamp: new Date().toISOString(),
      data: { received: data },
    };
  }

  @MessagePattern("telemetry/+/+")
  @ApiOperation({ summary: "Handle telemetry data from IoT devices" })
  async handleTelemetry(
    @Payload() data: MqttTelemetryDto,
    @Ctx() context: MqttContext,
  ): Promise<MqttResponseDto> {
    try {
      const topic = context.getTopic();
      this.logger.log(`üì° Received telemetry on ${topic}:`, data);

      // Map DTO to ITelemetry interface
      const telemetryData: ITelemetry = {
        id: '', // Will be generated by the service
        timestamp: data.timestamp,
        Temperature: data.Temperature,
        Humidity: data.Humidity,
        TVOC: data.TVOC,
        eCO2: data.eCO2,
        "Raw H2": data["Raw H2"],
        "Raw Ethanol": data["Raw Ethanol"],
        Pressure: data.Pressure,
        "PM1.0": data["PM1.0"],
        "PM2.5": data["PM2.5"],
        "NC0.5": data["NC0.5"],
        "NC1.0": data["NC1.0"],
        "NC2.5": data["NC2.5"],
        machineId: data.machineId.toString(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // Process the telemetry data
      await this.mqttService.processTelemetryData(telemetryData);

      return {
        success: true,
        message: "Telemetry data processed successfully",
        timestamp: new Date().toISOString(),
        data: { machineId: data.machineId, processed: true },
      };
    } catch (error) {
      this.logger.error(`‚ùå Failed to process telemetry:`, error);
      return {
        success: false,
        message: "Failed to process telemetry data",
        timestamp: new Date().toISOString(),
        data: { error: error.message },
      };
    }
  }

  @MessagePattern("alerts/+")
  @ApiOperation({ summary: "Handle alert messages" })
  async handleAlert(
    @Payload() data: MqttAlertDto,
    @Ctx() context: MqttContext,
  ): Promise<MqttResponseDto> {
    try {
      const topic = context.getTopic();
      this.logger.log(`üö® Received alert on ${topic}:`, data);

      // Publish alert to other subscribers
      await this.mqttService.publishAlert("alerts/broadcast", data);

      return {
        success: true,
        message: "Alert processed and broadcast successfully",
        timestamp: new Date().toISOString(),
        data: { alertType: data.type, machineId: data.machineId },
      };
    } catch (error) {
      this.logger.error(`‚ùå Failed to process alert:`, error);
      return {
        success: false,
        message: "Failed to process alert",
        timestamp: new Date().toISOString(),
        data: { error: error.message },
      };
    }
  }

  @MessagePattern("commands/+")
  @ApiOperation({ summary: "Handle command messages" })
  async handleCommand(
    @Payload() data: MqttCommandDto,
    @Ctx() context: MqttContext,
  ): Promise<MqttResponseDto> {
    try {
      const topic = context.getTopic();
      this.logger.log(`‚ö° Received command on ${topic}:`, data);

      // Process command based on type
      let result: any;
      switch (data.command) {
        case "RESTART_MACHINE":
          result = {
            action: "Machine restart initiated",
            machineId: data.machineId,
          };
          break;
        case "GET_STATUS":
          result = {
            action: "Status request processed",
            machineId: data.machineId,
          };
          break;
        default:
          result = { action: "Unknown command", command: data.command };
      }

      return {
        success: true,
        message: "Command executed successfully",
        timestamp: new Date().toISOString(),
        data: result,
      };
    } catch (error) {
      this.logger.error(`‚ùå Failed to execute command:`, error);
      return {
        success: false,
        message: "Failed to execute command",
        timestamp: new Date().toISOString(),
        data: { error: error.message },
      };
    }
  }

  @MessagePattern("status/request")
  @ApiOperation({ summary: "Handle status request" })
  async handleStatusRequest(
    @Payload() data: any,
    @Ctx() context: MqttContext,
  ): Promise<MqttResponseDto> {
    try {
      this.logger.log(`üìä Status request received on ${context.getTopic()}`);

      const connectionStatus = this.mqttService.getConnectionStatus();

      return {
        success: true,
        message: "MQTT service status",
        timestamp: new Date().toISOString(),
        data: {
          service: "MQTT",
          status: connectionStatus,
          uptime: process.uptime(),
          memory: process.memoryUsage(),
        },
      };
    } catch (error) {
      this.logger.error(`‚ùå Failed to get status:`, error);
      return {
        success: false,
        message: "Failed to get service status",
        timestamp: new Date().toISOString(),
        data: { error: error.message },
      };
    }
  }
}
